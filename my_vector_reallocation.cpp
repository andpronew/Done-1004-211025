/* Пример использования темплейта, буфера, хипа, вектора
Пошагово:
Создаёт пустой вектор a.
В цикле 200000 раз вызывает my_push_back(i):
Если не хватает места, расширяет буфер.
Копирует старые значения.
Добавляет новый элемент.
После завершения цикла — выводит 200000.
При выходе из main() вызывается деструктор, освобождающий память.

Проблема: линейное расширение +10 делает O(n^2) сложность — это неэффективно.
Лучше использовать удвоение

*/

#include <iostream>

using namespace std;

template<typename T>
class my_vector;

template<typename T>
class my_vector {
	int _sz = 0;        // Кол-во элементов в векторе (логический размер)
	T* _buf = nullptr;  // Указатель на динамический массив (буфер)
	int _capacity = 0;  // Физическая вместимость массива

public:
  ~my_vector() {
    delete [] _buf; //Освобождает память при уничтожении объекта, чтобы не было утечек
  }

  int size() {
    return _sz; //Возвращает текущее количество элементов в векторе
  }

  void my_push_back(T x) { //Добавляет элемент x в конец массива
    if (_sz >= _capacity) { //Если текущий размер _sz достиг ёмкости _capacity
      _capacity = _capacity*2 + 10; // Увеличиваем ёмкость в 2 раза + на 10
     // _capacity = _capacity + 10; // Увеличиваем ёмкость на 10
      T* ptr = new T[_capacity]; // Новый массив большего размера
      //cout<<"_capacity: "<<_capacity<<endl;
for(int i=0; i<_sz; i++) {
        ptr[i] = _buf[i]; // Копируем старые элементы
      }

      delete [] _buf; // Освобождаем старый массив
      _buf = ptr; // Переключаемся на новый
    }

    _buf[_sz] = x; // Записываем новый элемент
    _sz++; // Увеличиваем логический размер на 1
  }
};

int main() {
  my_vector<int> a; //Создаётся объект a, который хранит int

  for(int i=0; i<2*100000; ++i) //Добавляется 200 000 чисел (от 0 до 199999) в вектор. При этом my_push_back() будет реально выделять память 20000 раз (так как _capacity растёт на 10 — линейно)
  {
	  a.my_push_back(i);
}
	
  cout<<a.size()<<endl; //Выводится количество элементов в векторе: 200000
return 0;
}
