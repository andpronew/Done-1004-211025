AR_ARMA_2.cpp — это та же база, что и test_6.cpp, но в неё добавлена онлайн-логика принятия торговых решений и набор помощников для этого

Series: добавлено поле vector<double> price; (mid-price, выровненный по S.y), чтобы переводить прогнозы доходностей в ожидаемую абсолютную прибыль и логировать цену при сигнале.
ws (стек HL-моделей) остаётся, но рядом добавлены:
- vector<double> resid_ew_var — экспоненциальная (EW) оценка дисперсии остатков для каждой HL-модели (онлайн).
- idx_short, idx_med — индексы моделей «короткого» и «среднего» HL для правила консенсуса.
- TradeParams tp — структура с параметрами торговли (комиссия, slippage, kappa, max_lot, thresholds и т.д.).

Новые вспомогательные функции/структуры:
- half_life_bars_from_rho(double rho) — вычисляет half-life (в барах) из доминирующего корня rho.
- rel_move_from_logret(double yhat) и abs_move_from_logret(double price, double yhat) — перевод лог-доходности в относительное/абсолютное движение.
compute_size(double expected_rel, double sigma_resid, double kappa, double max_lot) — правило вычисления размера позиции (SNR → размер).
- TradeParams (структура параметров торговли).
- TradeDecision (структура результата: side, size, hold_bars).
- evaluate_trade_decision(...) — главная функция-правило, которая принимает:
прогнозы двух моделей (yhat_short, yhat_med), текущую цену, sigma_resid, rho_short, rho_med, n_eff и lb_pval, и возвращает решение: long/short/none, размер и рекомендованное время удержания (в барах).

Онлайн оценка дисперсии остатков (resid_ew_var):
- создаётся рядом с ws и обновляется в горячем цикле (каждый тренировочный тик); после получения yhat и расчёта e = y - yhat для каждой HL-модели выполняется EW-обновление. Нужна приближённая оценка условной дисперсии остатков для правила sizing (размер позиции зависит от оценки σ).

Правило «consensus short+med» и генерация сигналов:
после обновления всех моделей:
- Берутся yhat_short и yhat_med (predict_yhat для короткой и средней HL).
- Требуется одинаковый знак прогнозов и достаточная величина (min_expected_rel), т. е. оба предсказывают рост или падение и оба превышают порог.
- expected_rel = conservative min(rel_short, rel_med).
- Сравнивают expected_rel с cost = commission + expected_slippage. Торговать только если expected_rel > cost.
- Вычисляется size = compute_size(expected_rel, sigma_cons, kappa, max_lot).
- Вычисляется half_life из max(|rho_short|, |rho_med|) и hold_bars = min(H, k * half_life) (обычно k=1..3).
- Возвращается TradeDecision с side, signed size и hold_bars.
Вывод: сигнал не отправляет ордер (по умолчанию) — он логируется как TRADE_SIGNAL (в коде можно заменить на вызов API брокера).

Проверки/ограничения перед торговлей:
- N_eff: если n_eff (эффективный размер выборки, зависящий от lambda) ниже порога (min_neff) — торговля запрещена.
- LB p-value: если lb_pval меньше порога (например 0.01) — остатки автокоррелированы → торговля запрещена (консервативный режим).
- Порог expected_rel: минимальная относительная доходность, чтобы покрыть комиссии+slippage.
- Sigma protection: если нет адекватной оценки sigma_resid → не торговать (защита от деления на ноль).

Мониторинг/предупреждения:
- WARN: AR near unit root — теперь код предупреждает, когда rho превышает порог (например 0.95). Это служит триггером для:
	-уменьшения размера позиций,
	- увеличения регуляризации,
	- или перехода в консервативный режим.
- Периодическое логирование: вместе с прежними статистиками теперь печатаются rho, half_life в барах/сек, N_eff, sigma_resid и (по желанию) Новый лог TRADE_SIGNAL — текстовая строка в stdout с контекстом (time_idx, side, size, hold_bars, price, yhat_short/med, sigma), чтобы потом можно было анализировать сделки
- resid_ew_var, sigma_resid, и TRADE_SIGNAL логи — новые и пишутся регулярно.

Поведение программы кратко:
- В каждом шаге потоковой обработки модель(и) обновляются (как раньше).
- Дополнительно: для каждой модели поддержится онлайн оценка остаточной дисперсии (resid_ew_var).
- После обновления моделей проверяется правило consensus(short+med).
- При выполнении условий генерируется TRADE_SIGNAL (лог), где указаны: side, suggested size, hold_bars и контекст (price, yhat, rho, sigma, N_eff).
- Параллельно печатаются предупреждения о near-unit-root и мониторинговая статистика.
- CSV с модельными результатами по HL по-прежнему пишутся.

ВЫВОДЫ:
- Цена — теперь хранится и доступна S.price рядом с доходностями, поэтому прогнозы можно переводить в денежный результат.
- Онлайн-оценка волатильности (resid_ew_var) — пригодна для расчёта адекватного размера позиции (risk scaled sizing).
- Две модели с разными HL (short + med) и правило консенсуса — сигналы становятся более робастными (требуется согласие масштабов).
- Экономическая фильтрация сигналов — ожидаемая относительная прибыль сравнивается с commission + slippage, прежде чем отправлять сигнал.
- Правило расчёта размера (SNR-based, клиппинг по max_lot) — даёт конкретный рекомендуемый объём.
- Hold-logic основана на half-life (keep for k×half_life bars) — даёт временной критерий закрытия.
- Онлайн-мониторинг метрик (rho, N_eff, LB pval) и предупреждения (WARN: AR near unit root) — автоматические триггеры на консервативный режим.
- TRADE_SIGNAL лог — явный выход (time, side, size, hold, price, контекст) — удобен для dry-run и последующего бэктеста.
Что ещё остаётся невыполненным (почему это пока не «полный» торговый робот):
- Нет исполнения ордеров — код печатает/логирует сигнал, но не отправляет реальный ордер, не управляет fills, не отслеживает частичные исполнения.
- Нет управления позицией/маржой — как комбинировать множественные открытые позиции, агрегировать риски, контролировать P&L.
- Нет обработки проскальзывания в реальном времени (модель slippage сейчас фиксированная).
- Нет механизма Trailing/TP/SL, отмены/повторной оценки заявок.
- Нет надежной системы persistence / recovery — при перезапуске состояние (e_lags, y_lags, current positions) теряется.
- Нет реального risk engine (VaR, exposure limits, max drawdown).
- Нет latency/throughput оптимизаций для HF (avoid allocations, lock-free queues и т.д.).
- Нет интеграции с брокером / проверенного симулятора исполнения (важно для оценки экономической применимости).
AR_ARMA_2.cpp переводит нас от чистого исследования статистики к практическим торговым решениям: он генерирует сигналы, рассчитывает размер и время удержания, фильтрует по экономике сделки и следит за качеством модели
