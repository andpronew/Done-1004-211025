/* Создаёт три контейнера: собственный List<T>, стандартный std::list<T>, и std::vector<T>.
Добавляет в каждый из них 3 элемента.
Выводит:
Размер контейнера (size)
Читаемое имя типа (readable_type_name)
Содержимое контейнера (через итераторы)

Это полезно для:
Отладки/проверки шаблонов.
Сравнения поведения собственного контейнера со стандартными.
Демонстрации работы итераторов и шаблонной обобщённости.
*/
#include <iostream>    
#include <vector>      
#include <list>        
#include <typeinfo>    
#include <cxxabi.h>   

	template <typename T>
std::string readable_type_name() 
{
	const char* name = typeid(T).name();
	int status = 0;
	char* demangled = abi::__cxa_demangle(name, nullptr, nullptr, &status); 
	std::string result = (status == 0) ? demangled : name;  
	free(demangled); 
	return result; 
}

using namespace std;

template<typename T> //Класс List<T>, Реализуем свой двусвязный список. Это шаблон класса, который позволяет создавать класс List, работающий с разными типами данных. Например: List<int> — список целых чисел, List<string> — список строкб List<MyClass> — список объектов пользовательского класса.

class List // Внутри класса List определена структура ListNode:
{
	struct ListNode // Это вложенная структура, представляющая один элемент (узел) списка.Это внутренняя структура, описывающая один узел списка.Она доступна только внутри List, поскольку не объявлена как public.
			// Назначение ListNode: Используется для построения двусвязного списка. Позволяет эффективно вставлять и удалять элементы в начале, в середине и в конце без перемещения других элементов (в отличие от vector).
	{
		ListNode* prev{};  // Указатель на предыдущий элемент. Нужен для реализации двусвязного списка: можно перемещаться вперёд и назад.В начале списка (_front) поле prev будет nullptr.

		ListNode* next{};  // Указатель на следующий элемент. Позволяет переходить от текущего узла к следующему. В конце списка (_back) поле next будет nullptr.  
    }
		T data{};          // Данные узла. Хранит значение, которое передаёт пользователь.Тип значения — универсальный (шаблонный), т.е. T. Инициализируется значением по умолчанию: {} означает T{} — например: 0 для int, "" для string. Вызов конструктора по умолчанию для пользовательских типов
/* Визуализация одного узла: Если, например, T = int, то один узел в памяти будет выглядеть примерно так:
+----------------+------------+-------+
| prev (указатель) | data: int | next (указатель) |
+----------------+------------+-------+
Если есть несколько узлов, они связываются вот так:
nullptr <-- [prev | data=1 | next] <--> [prev | data=2 | next] <--> [prev | data=3 | next] --> nullptr */
	};
	ListNode* _front{};  // Указатель на начало списка:указатель на первый узел (начало) в двусвязном списке. Если список пуст — _front == nullptr.Используется для: Начала итерации по списку (begin()); Получения первого элемента через метод front(); Быстрой вставки в начало (если бы реализовался метод push_front()).
	ListNode* _back{};   // Указатель на конец списка: указатель на последний узел (конец) в списке.Если список пуст — _back == nullptr. Используется в: Методе push_back(), чтобы добавить элемент в конец за O(1); Методе back() — получить последний элемент; Если бы был метод pop_back() — удаление с конца.
	size_t _size{};      // Размер списка: Переменная, хранящая количество элементов в списке.Тип size_t — беззнаковое целое, предназначенное для счётчиков и индексов.Зачем нужен: Чтобы быстро вернуть размер списка через size(); Используется в методе empty() для проверки: пустой ли список (_size == 0); Увеличивается при добавлении, уменьшается при удалении элементов.
/* Взаимосвязь всех трёх:
Когда добавляешь элемент через push_back, например:
List<int> l;
l.push_back(5);
До:
_front == nullptr
_back == nullptr
_size == 0
После одного push_back(5):
_front → [data=5 | prev=nullptr | next=nullptr] ← _back
_size == 1
Если добавляешь ещё элемент:
l.push_back(10);
Теперь:
_front → [data=5 | prev=nullptr | next=⭢] → [data=10 | prev=⭠ | next=nullptr] ← _back
_size == 2
Почему всё это важно: Эти три поля Делают структуру полноценным двусвязным списком.
Позволяют:
Эффективно перебирать элементы,
Быстро добавлять в конец/начало,
Следить за размером без пересчёта (в отличие от некоторых наивных реализаций).
*/
	public:
	class iterator // Объявление вложенного класса iterator, это пользовательская реализация итератора для списка List<T>.Он позволяет использовать begin() и end(), а также цикл for, как с обычными STL-контейнерами (std::vector, std::list).
	{
		friend class List;  // Класс List может обращаться к приватным членам iterator, объявление friend class List; Класс List объявляется другом iterator, т.е. он может иметь доступ к приватным полям и методам iterator. Это нужно, например, чтобы метод begin() в List мог установить _ptr в нужное значение напрямую.
		ListNode* _ptr{};   // указатель на текущий узел списка, на котором "стоит" итератор.Именно этот указатель определяет, что будет возвращаться при разыменовании итератора (*it). begin() и end() устанавливают _ptr в соответствующее значение: begin() → _ptr = _front, end() → _ptr = nullptr

		public:
		bool operator!=(iterator it) // Перегрузка оператора !=   Позволяет сравнивать итераторы: возвращает true, если они указывают на разные узлы. Это нужно для цикла ниже в функции f(): for (iterator it = l.begin(); it != l.end(); ++it)
		{
			return _ptr != it._ptr;  // Сравнение итераторов
		}
		T& operator*() // Перегрузка оператора * (разыменование). Возвращает ссылку на данные текущего узла (T&), т.е. сам элемент списка.Позволяет писать: cout << *it;
		{
			return _ptr->data;       // Доступ к данным через разыменование
		}
		iterator& operator++() // Перегрузка оператора ++ (префиксный инкремент). Позволяет перейти к следующему узлу списка. Меняет указатель _ptr на следующий элемент: _ptr = _ptr->next. Возвращает ссылку на самого себя, чтобы можно было делать цепочки или использовать в for-цикле.
		{
			_ptr = _ptr->next;       // Переход к следующему элементу
			return *this;
		}
/* Как это работает на практике:
Когда вызываешь:
List<int>::iterator it = my_list.begin();
    it._ptr указывает на _front.
Когда делаешь:
++it;
    _ptr сдвигается на следующий элемент (_ptr = _ptr->next).
Когда сравниваешь:
it != my_list.end()
    сравниваются внутренние _ptr итераторов (nullptr у end()).
Когда разыменовываешь:
cout << *it;
    выводятся данные текущего узла (_ptr->data).
Вывод: этот итератор:
Очень похож на итератор std::list<T>::iterator.
Поддерживает минимальный набор: !=, *, ++, которого достаточно для range-for и обычного for.
Использует внутренний указатель _ptr, чтобы отслеживать позицию в двусвязном списке.
*/

};
	iterator end() //Методы begin() и end()
	{
		iterator it;
		return it;  // Конец — nullptr, используется как сигнал окончания
	}
/*
iterator end() — возвращает итератор, указывающий на элемент после последнего (как std::end() в стандартных контейнерах).
iterator it; — создаётся пустой итератор. Скорее всего, его внутренний указатель (_ptr) будет инициализирован значением nullptr.
return it; — возвращается этот итератор. Он сигнализирует, что дальнейших элементов нет. Именно по nullptr можно определить конец обхода.
Аналогия: как в книге указатель на пустую страницу означает, что вы дошли до конца. Здесь nullptr — такая «пустая страница».
*/
	iterator begin() 
	{
		iterator it;
		it._ptr = _front;  // Указатель на первый элемент
		return it;
	}
/*
iterator begin() — возвращает итератор, указывающий на первый элемент контейнера.
iterator it; — создаётся итератор.
it._ptr = _front; — итератору присваивается указатель на первый элемент списка (вероятно, узел со структурой Node, содержащей data и ссылки).
return it; — возвращается итератор на первый элемент.
Аналогия: как если вы ставите закладку на первую страницу книги.
*/
  size_t size() { return _size; } // Вспомогательные методы
/* size_t size() — возвращает текущее количество элементов в контейнере.
return _size; — возвращает значение переменной _size, которая где-то в классе ведёт подсчёт количества элементов.
Аналогия: вы спрашиваете, сколько книг в стопке — и получаете точное число.
*/
  bool empty() { return _size == 0; }
/* bool empty() — возвращает true, если контейнер пустой.
_size == 0 — логическое выражение, которое вернёт true, если размер равен нулю, иначе — false.
Аналогия: если у вас нет книг на полке, empty() скажет, что полка пуста.
*/
  T& front() { return _front->data; }
/* T& front() — возвращает ссылку на данные первого элемента контейнера.
_front->data — обращение к полю data структуры/класса, на которую указывает _front.
Аналогия: вы берёте самую первую книгу с полки — и получаете доступ к ней.
*/
  T& back() { return _back->data; }
/* T& back() — возвращает ссылку на данные последнего элемента.
_back->data — обращение к данным последнего узла, аналогично front().
Аналогия: вы достаёте последнюю книгу с конца полки.
*/
/* код начиная с iterator end() позволяет:
Итерироваться от begin() до end() (где end() — просто итератор с nullptr).
Получать доступ к первому и последнему элементам через front() и back().
Проверять пустоту через empty().
Узнавать размер с помощью size().
*/

	void push_back(T x) 
/* Метод push_back(T x) добавляет элемент в конец списка. это реализация двусвязного списка, где каждый узел хранит данные, указатель на предыдущий и следующий узлы.принимает значение x типа T (шаблонный параметр) и добавляет его в конец списка.Тип void означает, что метод ничего не возвращает.
*/
    {
		ListNode* p = new ListNode;  
/* Создаётся новый узел p динамически (в куче). new ListNode — выделяет память и вызывает конструктор по умолчанию.Это будет новый хвостовой элемент списка.
Аналогия: мы берём чистую карточку и готовим её для вставки в конец стопки. */

		p->prev = _back;             
/* Новый элемент указывает на текущий "хвост". У нового узла поле prev указывает на текущий _back (т.е. последний элемент списка до вставки).Это устанавливает связь назад, так как список двусвязный.Новый человек в очереди смотрит назад — видит того, кто был последним до него. */

		if (_back) 
//Проверяем, есть ли текущий конец списка (непустой ли он).Если _back != nullptr, значит, в списке уже есть хотя бы один элемент
		{
			_back->next = p;          
/* Старый хвост теперь ссылается на новый элемент.У текущего последнего элемента (_back) поле next начинает указывать на новый узел.Таким образом, связь вперёд устанавливается между старым хвостом и новым узлом.Человек, который раньше был последним, теперь знает, кто за ним в очереди.*/
		} 
		else 
		{
			_front = p;              
/* Если список был пуст, новый элемент — и начало, и конец.Если _back == nullptr, значит, список был пуст.Тогда новый узел становится первым и последним элементом, поэтому _front тоже указывает на него.Вы приходите первым — вы и первый, и последний в очереди.*/
		}
		_back = p;                  
// Обновляем указатель на конец. В любом случае (независимо от того, был ли список пуст), теперь p — новый хвост, и _back указывает на него
		p->data = x;                
// В поле data нового узла записывается переданное значение x.На карточке пишем нужные данные.
		_size++;                    // Увеличиваем счётчик элементов в списке.
	}
};
/* Кратко:
new ListNode	Создаётся новый узел
p->prev = _back	Новый узел связывается назад с текущим концом
_back->next = p (если есть)	Старый хвост связывается вперёд с новым узлом
_front = p (если пусто)	Если список пуст, новый узел становится началом
_back = p	Новый узел становится хвостом
p->data = x	Записываются данные
_size++	Размер увеличивается на 1 */

template<typename Container>
/* Это объявление шаблона функции: Container — параметр шаблона.Вы можете вызвать f<std::vector<int>>(), f<List<int>>(), и так далее.Это как универсальный рецепт, где Container — это тип формы для выпечки: кекс, хлеб, булочка — всё работает одинаково.*/

void f() // Шаблонная функция f, которую можно вызывать с любым типом контейнера (например, List<int>, std::vector<int>, и т.д.), при условии что он поддерживает нужные методы (push_back, size, begin, end, итератор с операцией разыменования и инкремента).
{
	Container l;            
/* Создаётся объект l типа Container.Это и есть контейнер, в который будут добавлены данные.Представьте: мы достаём пустую коробку — её тип пока абстрактный.*/

	l.push_back(1);
  l.push_back(2);
  l.push_back(3);
/* Добавляем в контейнер три элемента: 1, 2, 3.Метод push_back должен быть реализован у типа Container.Мы кладём три вещи в коробку: сначала яблоко, потом банан, потом грушу.*/

	cout << "size: " << l.size() << endl;   // Выводим размер: size: 3 — В пользовательском классе List<int> добавлено 3 элемента (1, 2, 3). List<int> — это имя типа, возвращённое функцией readable_type_name, которая преобразует typeid(T).name() в читаемый вид. 1 2 3 — Это значения, находящиеся в списке, полученные через пользовательский итератор
	cout << readable_type_name<Container>() << ":";  // Печатаем имя типа

	for (typename Container::iterator it = l.begin(); it != l.end(); ++it)
/* Классический цикл for, проходящий от начала до конца контейнера с помощью итератора.typename Container::iterator — тип итератора, используемый внутри контейнера Container.Мы начинаем с первой книги в стопке и листаем, пока не дойдём до последней.*/

		cout << " " << *it; 
/*  Печатаем значение, на которое указывает итератор it.Оператор * разыменовывает итератор и возвращает ссылку на текущий элемент.Печатает: 1 2 3 */
	cout << endl;
}
/* Кратко:
Универсальность	Использует шаблон Container
Добавление	Через push_back(…)
Размер	Метод size()
Печать элементов	Через итераторы: begin(), end(), *it
Отображение типа	readable_type_name<Container>() */

int main() {
	f<List<int>>();         
/* Используем самодельный список. Вызывается шаблонная функция f с аргументом шаблона List<int>.List<int> — это пользовательский двусвязный список, реализованный нами.
Функция f:
создаёт список List<int>,
добавляет в него элементы 1, 2, 3,
выводит его размер и содержимое через итераторы,
также показывает читаемое имя типа (List<int>).
Пример вывода:
size: 3
List<int>: 1 2 3
*/

	f<std::list<int>>();    
/* Вызывается f, но теперь с стандартным типом std::list<int>.Это контейнер из STL — тоже двусвязный список.
std::list поддерживает: push_back(), size(), итераторы (begin(), end()). Всё работает точно так же, как и с List<int>, что доказывает универсальность шаблонов.
Пример вывода:
size: 3
std::list<int>: 1 2 3
*/

	f<std::vector<int>>();  
/* Вызывается f, но с типом std::vector<int>. Это динамический массив из STL.Он тоже поддерживает push_back(), size(), begin(), end(), итераторы.Поведение будет тем же, но структура данных — совсем другая (вектор, а не список).
Пример вывода:
size: 3
std::vector<int>: 1 2 3
*/
  
	return 0;
}

